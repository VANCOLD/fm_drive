#include "feckinmad/fm_global"
#include "feckinmad/fm_sortedlist"
#include "feckinmad/fm_admin_access"
#include "feckinmad/fm_mapfunc"

#define	MAX_KEY	32
#define	MAX_VALUE 1024

#define MAX_MAP_TEXTURES 512
#define BSPVERSION 30

new const sDefaultPath[] = "resgen/fm_default_"
new const g_sTextFirstLine[] = "// Automatically generated by FM_RESGEN.amxx"

enum {
	TYPE_WAD,
	TYPE_TGA,
	TYPE_SPRITE,
	TYPE_MODEL,
	TYPE_SOUND,
	MAX_TYPES
}

new const sFileTypes[MAX_TYPES][4] = 
{
	"wad",
	"tga",
	"spr",
	"mdl",
	"wav"
}

new const sSkyboxDir[] = "gfx/env/"
new const sSkyboxSides[6][3] = 
{ 
	"up",
	"dn",
	"lf",
	"rt",
	"ft",
	"bk"
}

new const sBadStringContents[][] = 
{
	"\\",
	":",
	".."
}

new Array:g_DefaultResourceList[MAX_TYPES] = { Invalid_Array, ... }
new Array:g_ResourceList[MAX_TYPES] = { Invalid_Array, ... }

new bool:g_bExternalTextures

public plugin_init()
{
	fm_RegisterPlugin()

	if (LibraryExists (g_sAdminAccessLibName, LibType_Library))
	{
		register_concmd("admin_resgen", "Admin_Resgen", 0, "[map]")
	}
}

InitResArrays()
{
	fm_DebugPrintLevel(1, "InitResArrays()")

	for (new i = 0; i < MAX_TYPES; i++)
	{
		g_DefaultResourceList[i] = ArrayCreate(MAX_RESOURCE_LEN) // TODO: Profile this and test speed with lots of memory reallocation in ArrayPushString
		g_ResourceList[i] = ArrayCreate(MAX_RESOURCE_LEN)
	}

	ReadDefaultFiles()
}

CleanResArrays()
{
	fm_DebugPrintLevel(1, "CleanResArrays()")

	for (new i = 0; i < MAX_TYPES; i++)
	{
		ArrayDestroy(g_ResourceList[i]) 
		ArrayDestroy(g_DefaultResourceList[i]) 
	}
}

public Admin_Resgen(id, iLevel, iCommand)
{
	fm_DebugPrintLevel(1, "Admin_Resgen(%d, %d, %d)", id, iLevel, iCommand)

	if (!fm_CommandAccess(id, iLevel, false))
	{
		return PLUGIN_HANDLED
	}
	
	new sArgs[MAX_MAP_LEN]; read_args(sArgs, charsmax(sArgs))
	trim(sArgs) 
	
	if (!sArgs[0])
	{
		InitResArrays()
		ReadMapDir(id)
		CleanResArrays()
	}
	else if (fm_GetProperMapName(sArgs))
	{
		InitResArrays()
	
		if (CreateRes(sArgs))
		{
			console_print(id, "Successfully created resource file for map: \"%s\"", sArgs)
		}
		else
		{
			console_print(id, "Failed to create resource file for map: \"%s\"", sArgs)
		}

		CleanResArrays()
	}
	else
	{
		console_print(id, "Unable to create resource file as \"%s\" is not a valid map", sArgs)
	}
	
	return PLUGIN_HANDLED
}

ReadMapDir(id)
{
	fm_DebugPrintLevel(1, "ReadMapDir(%d)", id)

	new sMapName[MAX_MAP_LEN], iLen

	new iDirHandle = open_dir("maps/", sMapName, charsmax(sMapName))
	if (!iDirHandle)
	{
		fm_WarningLog("Unable to open maps directory")
		return 0
	}
	
	new iSuccessTotal, iFailTotal	
	do {
		iLen = strlen(sMapName) - 4
		if (iLen < 0)
		{
			continue 		
		}
	
		if(!equali(sMapName[iLen], ".bsp")) 
		{
			continue
		}

		sMapName[iLen] = '\0'		

		for (new i = 0; i < MAX_TYPES; i++)
		{
			ArrayClear(g_ResourceList[i]) 
		}

		if (CreateRes(sMapName))
		{
			iSuccessTotal++
		}
		else
		{
			iFailTotal++
		}

	} while (next_file(iDirHandle, sMapName, charsmax(sMapName)))

	close_dir(iDirHandle)
	console_print(id, "Created %d resource file%s. (Failed: %d)", iSuccessTotal, iSuccessTotal != 1 ? "s" : "", iFailTotal)

	return 1
}

public plugin_precache()
{
	// The case of sCurrentMap depends on the argument passed to changelevel
	new sCurrentMap[MAX_MAP_LEN]; get_mapname(sCurrentMap, charsmax(sCurrentMap))

	// Get the the actual .bsp name to ensure we read/create the res file in the same case (not as crucial on win32)
	if (!fm_GetProperMapName(sCurrentMap))  
	{
		fm_WarningLog("Unable to get directory map name for map: \"%s\"", sCurrentMap)
		return PLUGIN_CONTINUE
	}

	new sFile[128]; formatex(sFile, charsmax(sFile), "maps/%s.res", sCurrentMap)
	new iFileHandle = fopen(sFile, "rt")
	if (iFileHandle)
	{
		new sLine[128]; fgets(iFileHandle, sLine, charsmax(sLine))
		fclose(iFileHandle)

		// Check the .res file was generated by this plugin
		if (equal(sLine, g_sTextFirstLine, strlen(g_sTextFirstLine)))
		{
			return PLUGIN_CONTINUE
		}
	}
	
	InitResArrays()
	CreateRes(sCurrentMap)	
	CleanResArrays()

	return PLUGIN_CONTINUE
}

// Read the files that come with the game to avoid including non custom content in the .res file
ReadDefaultFiles()
{
	fm_DebugPrintLevel(1, "ReadDefaultFiles()")

	new sConfigFile[128], sSortedFile[128], sDataDirectory[128], sHash[34]
	get_localinfo("amxx_datadir", sDataDirectory, charsmax(sDataDirectory))

	for (new i = 0; i < MAX_TYPES; i++)
	{
		formatex(sConfigFile, charsmax(sConfigFile), "%s/%s%s.ini", sDataDirectory, sDefaultPath, sFileTypes[i])
		formatex(sSortedFile, charsmax(sSortedFile), "%s/%s%s_sorted.dat", sDataDirectory, sDefaultPath, sFileTypes[i])

		if (file_exists(sConfigFile))
		{
			hash_file(sConfigFile, Hash_Md5, sHash, charsmax(sHash))
		}

		if (!ReadDefaultListSorted(g_DefaultResourceList[i], sSortedFile, sHash))
		{
			if (ReadDefaultListConfig(g_DefaultResourceList[i], sConfigFile))
			{
				ArraySort(Array:g_DefaultResourceList[i], "Handle_DefaultListCompare")
				WriteDefaultListSorted(Array:g_DefaultResourceList[i], sSortedFile, sHash)
			}
		}	
	}
}

ReadDefaultListSorted(Array:ResourceList, sFile[], sHash[34])
{
	fm_DebugPrintLevel(1, "ReadDefaultListSorted()")

	new iFileHandle = fopen(sFile, "rb")
	if (!iFileHandle)
	{
		//fm_WarningLog(FM_FOPEN_WARNING, sFile)
		return 0
	}

	// Check if config file has been updated
	new sSortedHash[34]; fread_blocks(iFileHandle, sSortedHash, sizeof(sHash), BLOCK_CHAR)
	if (!equal(sSortedHash, sHash))
	{
		return 0
	}

	// Read resource count
	new iCount; fread(iFileHandle, iCount, BLOCK_INT)

	// Read resources
	new sResource[MAX_RESOURCE_LEN]
	for (new i = 0; i < iCount; i++)
	{
		fread_blocks(iFileHandle, sResource, MAX_RESOURCE_LEN, BLOCK_CHAR)
		ArrayPushString(ResourceList, sResource)
	}

	fclose(iFileHandle)

	return 1
}

ReadDefaultListConfig(Array:ResourceList, sFile[])
{
	fm_DebugPrintLevel(1, "ReadDefaultListConfig(%d, %s)", ResourceList, sFile)

	new iFileHandle = fopen(sFile, "rt")
	if (!iFileHandle) 
	{
		fm_WarningLog(FM_FOPEN_WARNING, sFile)
		return 0
	}

	new iCount, sData[MAX_RESOURCE_LEN]
	while (!feof(iFileHandle))
	{
		fgets(iFileHandle, sData, charsmax(sData))
		trim(sData)

		if (!sData[0]) 
		{
			continue
		}

		ArrayPushString(Array:ResourceList, sData)
		iCount++
	}

	fclose(iFileHandle)
	return 1
}


WriteDefaultListSorted(Array:ResourceList, sFile[], sHash[34])
{
	fm_DebugPrintLevel(1, "WriteDefaultListSorted(%d, %s)", ResourceList, sFile)

	new iFileHandle = fopen(sFile, "wb")
	if (!iFileHandle) 
	{
		fm_WarningLog(FM_FOPEN_WARNING, sFile)
		return 0
	}

	// Write default file hash so we can check for changes instead of sorting every time
	fwrite_blocks(iFileHandle, sHash, sizeof(sHash), BLOCK_CHAR)

	new sBuffer[MAX_RESOURCE_LEN], iSize = ArraySize(ResourceList)

	// Write resource count
	fwrite(iFileHandle, iSize, BLOCK_INT)

	for (new i = 0; i < iSize ; i++)
	{
		arrayset(sBuffer, 0, MAX_RESOURCE_LEN)
		ArrayGetString(Array:ResourceList, i, sBuffer, charsmax(sBuffer))
		fwrite_blocks(iFileHandle, sBuffer, MAX_RESOURCE_LEN, BLOCK_CHAR)
	}

	fclose(iFileHandle)

	return 1
}


public Handle_DefaultListCompare(Array:ResourceList, iItem1, iItem2)
{
	static sItem1[MAX_RESOURCE_LEN], sItem2[MAX_RESOURCE_LEN]

	ArrayGetString(ResourceList, iItem1, sItem1, charsmax(sItem1))
	ArrayGetString(ResourceList, iItem2, sItem2, charsmax(sItem2))

	// The client will have these files on the windows platform which is case insensitive
	return strcmp(sItem1, sItem2, 1)
}


CreateRes(sMap[])
{	
	fm_DebugPrintLevel(1, "CreateRes(%s)", sMap)

	new sFile[128]; formatex(sFile, charsmax(sFile), "maps/%s.bsp", sMap)

	// For furure reference rb+ is required to overwrite sections of the bsp. But the climb server didn't like it
	new iFileHandle = fopen(sFile, "rb") 
	if (!iFileHandle)
	{
		fm_WarningLog(FM_FOPEN_WARNING, sFile)
		return 0
	}
	
	if (ReadMap(iFileHandle, sMap) && WriteRes(sMap))
	{
		log_amx("Successfully created resource file for map: \"%s\"", sMap)
		return 1
	}
	else
	{
		log_amx("Failed to create resource file for map: \"%s\"", sMap)
	}
	return 0
}



ReadMap(iFileHandle, sMap[])
{
	g_bExternalTextures = false

	//------------------------------------------------------------------------------------
	// Check the BSP version
	//------------------------------------------------------------------------------------

	fm_DebugPrintLevel(1, "ReadMap(%d, \"%s\")", iFileHandle, sMap)

	new iVersion
	if (fread(iFileHandle, iVersion, BLOCK_INT) != BLOCK_INT)
	{
		fm_WarningLog("%s: Failed to read BSP version.", sMap)
		return 0
	}

	if (iVersion != BSPVERSION)
	{
		fm_WarningLog("%s: Unexpected BSP version. Expected %d. Got %d", sMap, BSPVERSION, iVersion)
		return 0
	}

	//------------------------------------------------------------------------------------
	// Get the offset and size of the entity data
	//------------------------------------------------------------------------------------

	fm_DebugPrintLevel(2, "Reading entdata lumpinfo")

	new iEntOffset
	if (fread(iFileHandle, iEntOffset, BLOCK_INT) != BLOCK_INT) 
	{
		fm_WarningLog("%s: Failed to read entdata file offset", sMap)
		return 0
	}

	new iEntDataSize
	if (fread(iFileHandle, iEntDataSize, BLOCK_INT) != BLOCK_INT)  
	{
		fm_WarningLog("%s: Failed to read entdata size", sMap)
		return 0
	}

	//------------------------------------------------------------------------------------
	// Seek past the planes lumpinfo and read the file offset for the texture data
	//------------------------------------------------------------------------------------

	fm_DebugPrintLevel(2, "Reading texdata lumpinfo")

	if (fseek(iFileHandle, 20, SEEK_SET))
	{
		fm_WarningLog("%s: Failed to seek to texdata lumpinfo", sMap)
		return 0
	}

	new iTexOffset
	if (fread(iFileHandle, iTexOffset, BLOCK_INT) != BLOCK_INT)
	{
		fm_WarningLog("%s: Failed to read texdata file offset", sMap)
		return 0
	}

	//------------------------------------------------------------------------------------
	// Seek to the location of the entity data and begin parsing the keyvalue pairs
	//------------------------------------------------------------------------------------	

	fm_DebugPrintLevel(2, "Reading entdata")

	if (fseek(iFileHandle, iEntOffset, SEEK_SET))
	{
		fm_WarningLog("%s: Failed to seek to entdata offset", sMap)
		return 0
	}

	new iEndOffset = iEntOffset + iEntDataSize // Calculate end offset of entdata	
	static sData[MAX_KEY + MAX_VALUE + 8], sKey[MAX_KEY], sValue[MAX_VALUE]

	while(ftell(iFileHandle) < iEndOffset)
	{	
		if (feof(iFileHandle))
		{
			fm_WarningLog("%s: Unexpected end of file", sMap)
			return 0
		}
		
		fgets(iFileHandle, sData, charsmax(sData))

		if (!sData[0] || sData[0] == '{' || sData[0] == '}')
		{
			continue
		}

		//sKey[0] = sValue[0] = '\0'
		if (parse(sData, sKey, charsmax(sKey), sValue, charsmax(sValue)) == 2)
		{
			Handle_EntKeyValuePair(sKey, sValue)
		}
	}

	// Only check if the external wadlist is valid or if the textures are actually all embedded if we have custom wads to check
	if (!ArraySize(Array:g_ResourceList[TYPE_WAD]))
	{
		return 1
	}

	//------------------------------------------------------------------------------------
	// Seek to the location of the texture data and read the texture count	
	//------------------------------------------------------------------------------------	

	fm_DebugPrintLevel(2, "Reading texdata count")

	if (fseek(iFileHandle, iTexOffset, SEEK_SET))
	{
		fm_WarningLog("%s: Failed to seek to texdata offset", sMap)
		return 0
	}

	new iTextureCount
	if (fread(iFileHandle, iTextureCount, BLOCK_INT) != BLOCK_INT)
	{
		fm_WarningLog("%s: Failed to read texture count", sMap)
		return 0
	}

	if (iTextureCount > MAX_MAP_TEXTURES)
	{
		fm_WarningLog("%s: Textures > %d!", sMap, MAX_MAP_TEXTURES)
		return 0
	}

	//------------------------------------------------------------------------------------
	// Read the file offsets for each texture
	//------------------------------------------------------------------------------------	

	fm_DebugPrintLevel(2, "Reading texdata offsets")

	new iTextureOffsets[MAX_MAP_TEXTURES]
	if (fread_blocks(iFileHandle, iTextureOffsets, iTextureCount, BLOCK_INT) != iTextureCount)
	{
		fm_WarningLog("%s: Failed to read texture offsets", sMap)
		return 0
	}	

	//------------------------------------------------------------------------------------
	// Loop through all the textures and check offsets to determine if the map has external textures 
	//------------------------------------------------------------------------------------

	fm_DebugPrintLevel(2, "Reading textures")

	new /*sTextureName[16], iWidth, iHeight,*/ iOffsets[4]
	for (new i = 0; i < iTextureCount; i++)
	{
		if (fseek(iFileHandle, iTexOffset + iTextureOffsets[i] + 24, SEEK_SET))
		//if (fseek(iFileHandle, iTexOffset + iTextureOffsets[i], SEEK_SET))
		{
			fm_WarningLog("%s: Failed to seek to texture offsets", sMap)
			return 0
		}

		/*
		if (fread_blocks(iFileHandle, sTextureName, sizeof sTextureName, BLOCK_CHAR) != sizeof sTextureName)
		{
			fm_WarningLog("%s: Failed to read texture name", sMap)
			return 0
		}

		if (fread(iFileHandle, iWidth, BLOCK_INT) != BLOCK_INT || fread(iFileHandle, iHeight, BLOCK_INT) != BLOCK_INT)
		{
			fm_WarningLog("%s: Failed to read texture width/height", sMap)
			return 0
		}
		*/

		if (fread_blocks(iFileHandle, iOffsets, sizeof iOffsets, BLOCK_INT) !=  sizeof iOffsets)
		{
			fm_WarningLog("%s: Failed to read texture offsets", sMap)
			return 0
		}

		//fm_DebugPrint("Texture: %s Width: %d Height: %d Offsets: { %d, %d, %d, %d }", sTextureName, iWidth, iHeight, iOffsets[0], iOffsets[1], iOffsets[2], iOffsets[3])
		
		//------------------------------------------------------------------------------------
		// If the offsets for each mip level are 0 the texture must be in a external texture file
		// I can break out of this now because we've determined that the wad resource list is valid
		//------------------------------------------------------------------------------------
		if (iOffsets[0] == 0 && iOffsets[1] == 0 && iOffsets[2] == 0 && iOffsets[3] == 0)
		{
			g_bExternalTextures = true
			break
		}
	}
	return 1
}

Handle_EntKeyValuePair(sKey[MAX_KEY], sValue[MAX_VALUE])
{
	//fm_DebugPrintLevel(1, "Handle_EntKeyValuePair(\"%s\" \"%s\")", sKey, sValue)

	if (equal(sKey, "wad"))
	{	
		new sWad[128]
		for(;;)
		{
			// Each wad path is split by a semicolon
			strtok(sValue, sWad, charsmax(sWad), sValue, charsmax(sValue), ';')
			if (!sWad[0])
			{
				break
			}

			// Add the wad. The textures may be embedded, but this is checked later
			// If all textures are embedded this "wad" key often contains custom wad files that don't actually exist
			AddResource(TYPE_WAD, "%s", sWad[fm_GetFileNameFromPath(sWad)])	
		}
		return 1
	}

	if (equal(sKey, "skyname"))
	{	
		// Deal with maps that share the same skybox but have variable case
		strtolower(sValue)

		for (new i = 0; i < 6; i++)
		{
			AddResource(TYPE_TGA, "%s%s%s.tga", sSkyboxDir, sValue, sSkyboxSides[i])	
		}
		return 1
	}

	if (equal(sKey, "replacement_model"))
	{
		AddResource(TYPE_MODEL, "models/player/%s/%s.mdl", sValue, sValue)
		return 1
	}

	//----------------------------------------------------------------------------------------------------------------------------------------
	// Check the end of the value info to see if it matches a file extension
	// Technically a mapper could put a string that looks like a resource into a key that isn't meant for one
	// But I haven't come across it yet in the 1000 odd maps I've generated .res files for
	//----------------------------------------------------------------------------------------------------------------------------------------

	new iExt = strlen(sValue) - 4
	if (iExt <= 0 || sValue[iExt++] != '.')
	{
		return 0
	}

	//----------------------------------------------------------------------------------------------------------------------------------------
	// Also... some resources are precached automatically by the engine, if they are listed in the .res file too clients download it twice.
	// This is a waste of bandwidth and is fraustratingly time consuming when you are on a shit connection, hence the comments below
	// I have not omitted them altogether because its useful to know what custom resources a map requires and check if any are missing
	//----------------------------------------------------------------------------------------------------------------------------------------

	if (equali(sValue[iExt], sFileTypes[TYPE_SOUND]))
	{
		// "speak" is a valid way of playing a sound and it isn't precached by the engine. http://fm.myklol.net/forum/viewtopic.php?t=2529#36261
		// The only tiny bug I can see is if the map used the same sound for both of these, you would have two entries of basically the same file, apart from one would be commented
		if (equal(sKey, "speak"))
		{
			AddResource(TYPE_SOUND, "sound/%s", sValue)
		}
		else
		{
			AddResource(TYPE_SOUND, "// sound/%s", sValue)
		}
		return 1
	}

	if (equali(sValue[iExt], sFileTypes[TYPE_SPRITE]))
	{
		AddResource(TYPE_SPRITE, "// %s", sValue)
		return 1
	}
	
	if (equali(sValue[iExt], sFileTypes[TYPE_MODEL]))
	{ 
		if (AddResource(TYPE_MODEL, "// %s", sValue))
		{
			// Check if the model has external textures as these are not precached automatically
			new iFileHandle = fopen(sValue, "rb")
			if (iFileHandle)
			{
				// Skip 180 bytes into the mdl header to get the texture count
				fseek(iFileHandle, 180, SEEK_SET) 
				new iTextures; fread(iFileHandle, iTextures, BLOCK_INT)
				fclose(iFileHandle)

				if (!iTextures)
				{
					sValue[strlen(sValue) - 4] = '\0'
					AddResource(TYPE_MODEL, "%sT.mdl", sValue)
					return 1
				}
			}
		}		
	}
	return 0
}

AddResource(iType, sFormat[], any:...)
{
	new sResource[MAX_RESOURCE_LEN]; vformat(sResource, charsmax(sResource), sFormat, 3)
	//fm_DebugPrintLevel(1, "AddResource(%d \"%s\")", iType, sResource)

	// Check if the resource already exists in the resource list. Case sensitive since we are running linux
	// If a map uses a resource more than once but the case varies it should be flagged since it will cause download problems

	new iSize = ArraySize(g_ResourceList[iType])
	if (fm_BinarySearch(g_ResourceList[iType], sResource, 0, iSize - 1) == -1)
	{
		new iPos
		if (equal(sResource, "// ", 3))
		{
			iPos = 3
		}

		iSize = ArraySize(g_DefaultResourceList[iType])
		if (iSize > 0)
		{
			// Check if the resource is one that comes with the game 
			if (fm_BinarySearch(g_DefaultResourceList[iType], sResource[iPos], 0, iSize - 1, 1) != -1)
			{
				return 0
			}
		}
		fm_InsertIntoSortedList(g_ResourceList[iType], sResource)
	}
	return 1
}

WriteRes(sMap[])
{
	fm_DebugPrintLevel(1, "WriteRes(%s)", sMap)

	new sFile[128]; formatex(sFile, charsmax(sFile), "maps/%s.res", sMap)
	new iFileHandle = fopen(sFile, "wt")
	if (!iFileHandle)
	{
		fm_WarningLog(FM_FOPEN_WARNING, sFile)
		return 0
	}

	new sResource[MAX_RESOURCE_LEN], iPos

	new sTime[64]; get_time("%d/%m/%Y - %H:%M:%S", sTime, charsmax(sTime))
	fprintf(iFileHandle, "%s on %s. Author: watch. Compile Date: %s\n", g_sTextFirstLine, sTime, FM_SCRIPT_DATE)

	for (new i = 0; i < MAX_TYPES; i++)
	{
		//------------------------------------------------------------------------------------------------------------------------------------
		// Don't go any further with the wad list if all the textures are embedded
		// Since the "wad" key only contains valid wad files if at least one texture is external to the bsp
		//------------------------------------------------------------------------------------------------------------------------------------
		if (!g_bExternalTextures && i == TYPE_WAD)
		{
			continue
		}

		for(new j = 0, iSize = ArraySize(Array:g_ResourceList[i]); j < iSize; j++)
		{
			ArrayGetString(Array:g_ResourceList[i], j, sResource, charsmax(sResource))
			
			//----------------------------------------------------------------------------------------------------------------------------
			// Check commented resource exist too. Even though the game will ignore these entries when reading the res
			// they will still need to exist for the engine to precache them, so its good to know if they are missing.
			// Also it means the the .res files can be easily read by other plugins that want to do shit with custom map resources.
			// Like check it exists on a HTTP server using sockets or precache it in lowercase for consistency
			//----------------------------------------------------------------------------------------------------------------------------

			iPos = 0
			if (equal(sResource, "// ", 3))
			{
				iPos = 3
			}

			CheckResourceExists(sResource[iPos], sMap)
			fprintf(iFileHandle, "%s\n", sResource)
		}
	}

	fclose(iFileHandle)
	return 1
}

CheckResourceExists(sResource[], sMap[])
{
	//fm_DebugPrintLevel(1, "CheckResourceExists(%s)", sResource)

	// HL will ignore resources read from res files if they contain any of these strings
	for (new i = 0; i < sizeof sBadStringContents; i++)
	{
		if (containi(sResource, sBadStringContents[i]) != -1)
		{
			fm_WarningLog("%s: Resource \"%s\" contains invalid string: \"%s\"", sMap, sResource, sBadStringContents[i])
			return 0
		}
	}

	if (!file_exists(sResource))
	{
		fm_WarningLog("%s: Resource \"%s\" is missing", sMap, sResource)
		return 0
	}

	return 1
}

public plugin_natives()
{
	set_module_filter("Module_Filter")
	set_native_filter("Native_Filter")
}

public Module_Filter(sModule[])
{
	// Load the plugin even if the fm admin access plugin is not running
	if (equal(sModule, g_sAdminAccessLibName))
	{
		return PLUGIN_HANDLED 
	}
	return PLUGIN_CONTINUE
}

public Native_Filter(sName[], iIndex, iTrap)
{
	if (!iTrap)
	{
		return PLUGIN_HANDLED	
	}
	return PLUGIN_CONTINUE
}