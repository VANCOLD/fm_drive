#include "feckinmad/fm_global"
#include "feckinmad/fm_mapfunc"

#include <sockets>
#include <fakemeta>
#include <nvault>

#define RETRY_COUNT 1
#define CACHE_AGE_RECHECK 60 * 60 * 24 * 90 // 90 Days

new g_pCvarContentServer
new g_pCvarLogSuccess

new g_sMapDir[] = "maps/"
new const g_sVaultName[] = "fm_contentcheck_cache"

new const g_sUserAgent[] = "FM-ContentCheck/0.4"
new const g_sTextFirstLine[] = "Automatically generated by FM_RESGEN.amxx"

new g_sContentDomain[256]
new g_sContentPath[128]

new Array:g_sResourceList
new g_iCacheVault

new g_sMap[MAX_MAP_LEN]
new g_bFailure

enum eContent_t
{
	m_iSocketHandle,
	m_iResourceIndex,
	m_iRetryCount,
	m_iLocalSize
} 

public plugin_init()
{
	fm_RegisterPlugin()

	get_mapname(g_sMap, charsmax(g_sMap))
	fm_GetProperMapName(g_sMap)

	g_pCvarLogSuccess = register_cvar("fm_contentcheck_logall", "0")

	g_iCacheVault = nvault_open(g_sVaultName)
	if (g_iCacheVault == INVALID_HANDLE)
	{
		fm_WarningLog("Failed to open vault \"%s\"", g_sVaultName)
		return PLUGIN_CONTINUE
	}

	nvault_prune(g_iCacheVault, 0,  get_systime() - CACHE_AGE_RECHECK)

	if (!nvault_get(g_iCacheVault, g_sMap))
	{
		// Delay is to ensure server.cfg had loaded.
		g_sResourceList = ArrayCreate(MAX_RESOURCE_LEN)
		set_task(1.0, "CheckMapResources", 0, g_sMap, MAX_MAP_LEN)
	}

	return PLUGIN_CONTINUE	
}

public plugin_end()
{
	if (g_sResourceList != Invalid_Array)
	{
		ArrayDestroy(g_sResourceList)
	}

	if (g_iCacheVault != INVALID_HANDLE)
	{
		nvault_close(g_iCacheVault)
	}
}

public CheckMapResources()
{
	if (!ParseDownloadURLCvar())
	{
		return PLUGIN_HANDLED
	}

	fm_ResourceLog("Checking map: %s", g_sMap)
	AddResource("%s%s.bsp", g_sMapDir, g_sMap)

	new sFile[128]; formatex(sFile, charsmax(sFile), "%s%s.txt", g_sMapDir, g_sMap)
	if (file_exists(sFile))
	{
		AddResource(sFile)
	}

	formatex(sFile, charsmax(sFile), "%s%s.res", g_sMapDir, g_sMap)
	new iFileHandle = fopen(sFile, "rt")

	if (!iFileHandle)
	{
		fm_WarningLog(FM_FOPEN_WARNING, sFile)
		return PLUGIN_HANDLED
	}

	new sData[MAX_RESOURCE_LEN], iPos
	while (!feof(iFileHandle))
	{
		fgets(iFileHandle, sData, charsmax(sData))
		trim(sData)
				
		if (!sData[0])
		{
			continue
		}


		if (equal(sData, "//", 2))
		{
			if (equal(sData[3], g_sTextFirstLine, strlen(g_sTextFirstLine)))
			{
				continue
			}
			iPos = 3
		}
		else
		{
			iPos = 0
		}

		AddResource("%s", sData[iPos])
	}

	fclose(iFileHandle)
	CheckNextResource()

	return PLUGIN_HANDLED
}

ParseDownloadURLCvar()
{
	g_pCvarContentServer = get_cvar_pointer("sv_downloadurl")
	if (!g_pCvarContentServer)
	{
		fm_WarningLog("sv_downloadurl cvar does not exist")
		return 0
	}

	new sContentServer[128]; get_pcvar_string(g_pCvarContentServer, sContentServer, charsmax(sContentServer))
	if (!sContentServer[0])
	{
		fm_WarningLog("sv_downloadurl is blank")
		return 0
	}

	// This error checking is also performed by hl. Although https is also supported, but fuck it for now
	if (!equali(sContentServer, "http://", 7)) 
	{
		fm_WarningLog("sv_downloadurl must begin with \"http://\"")
		return 0
	}	

	strtok(sContentServer[7], g_sContentDomain, charsmax(g_sContentDomain), g_sContentPath, charsmax(g_sContentPath), '/')

	console_print(0, "\"%s\" \"%s\"", g_sContentDomain, g_sContentPath)

	return 1
}

AddResource(sResource[], any:...)
{
	static sBuffer[MAX_RESOURCE_LEN]; vformat(sBuffer, charsmax(sBuffer), sResource, 2)
	ArrayPushString(g_sResourceList, sBuffer)
}


CheckNextResource()
{
	if (ArraySize(g_sResourceList) > 0)
	{
		CheckContent(0)
	}
	else if (!g_bFailure)
	{
		nvault_set(g_iCacheVault, g_sMap, "1")
	}
}

CheckContent(iIndex)
{
	fm_DebugPrintLevel(1, "CheckContent(%d)", iIndex)

	static sResource[MAX_RESOURCE_LEN]; ArrayGetString(g_sResourceList, iIndex, sResource, charsmax(sResource))

	new iSocketError, iSocketHandle
	if ((iSocketHandle = socket_open(g_sContentDomain, 80, SOCKET_TCP, iSocketError)) <= 0)
	{
		fm_WarningLog("Could not connect to verify resource: \"%s\"", sResource)
		return
	}

	static sBuffer[1024]
	new iLen = formatex(sBuffer, charsmax(sBuffer), "GET /%s%s HTTP/1.1\r\n", g_sContentPath, sResource)
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer) - iLen, "Host: %s\r\n", g_sContentDomain)
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer) - iLen, "User-Agent: %s\r\n", g_sUserAgent)
	iLen += formatex(sBuffer[iLen], charsmax(sBuffer) - iLen, "Connection: close\r\n\r\n")

	fm_DebugPrintLevel(2, "%s", sBuffer)
	socket_send(iSocketHandle, sBuffer, strlen(sBuffer))
	
	new sData[eContent_t]
	sData[m_iSocketHandle] = iSocketHandle
	sData[m_iResourceIndex] = iIndex
	sData[m_iRetryCount] = 0
	sData[m_iLocalSize] = file_size(sResource)

	set_task(1.0, "CheckSocketChange", 0, sData, eContent_t , "a", RETRY_COUNT)
	return
}

public CheckSocketChange(sData[eContent_t])
{
	new iSocketHandle = sData[m_iSocketHandle]
	
	fm_DebugPrintLevel(2, "sData[m_iResourceIndex]: %d sData[m_iRetryCount]: %d", sData[m_iResourceIndex], sData[m_iRetryCount])
	static sResource[MAX_RESOURCE_LEN]; ArrayGetString(g_sResourceList, sData[m_iResourceIndex], sResource, charsmax(sResource))

	if (!socket_change(iSocketHandle, 1))
	{
		if (sData[m_iRetryCount] >= RETRY_COUNT)
		{
			fm_ResourceLog("No response to verify resource: \"%s\"", sResource)
			socket_close(iSocketHandle)
			
			ArrayDeleteItem(g_sResourceList, sData[m_iResourceIndex])
			CheckNextResource()
			g_bFailure = true
			return PLUGIN_HANDLED
		}
		sData[m_iRetryCount]++
		set_task(1.0, "CheckSocketChange", 0, sData, eContent_t)

		return PLUGIN_HANDLED
	}	

	static sBuffer[1024]; sBuffer[0] = 0
	socket_recv(iSocketHandle, sBuffer, charsmax(sBuffer))	

	static sLine[64]
	new iRemoteSize, iLineCount, iLen

	for(;;)
	{
		sLine[0] = 0
		strtok(sBuffer, sLine, charsmax(sLine), sBuffer, charsmax(sBuffer), '\n')
		if (!sLine[0])
		{
			break				
		}

		iLineCount++

		// Strip CR
		iLen = strlen(sLine)
		if (--iLen < 0)
		{
			continue
		}

		if (sLine[iLen] == '\r')
		{
			sLine[iLen] = 0
		}

		// The first line of a Response message is the Status-Line
		// Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
		if (iLineCount == 1)
		{
			if (!equal(sLine, "HTTP/1.1 200 OK") || get_pcvar_num(g_pCvarLogSuccess) == 1)
			{
				fm_ResourceLog("%s \"%s\"", sLine, sResource)	
				break
			}
						
		}
		else if (equal(sLine, "Content-Length: ", 16))
		{
			iRemoteSize = str_to_num(sLine[16])

			if (sData[m_iLocalSize] != -1 && sData[m_iLocalSize] != iRemoteSize)
			{
				fm_ResourceLog("Size Difference: \"%s\" Local size: %d Remote size: %d", sResource, sData[m_iLocalSize], iRemoteSize)
			}
			break
		}
	}
	socket_close(iSocketHandle)
	ArrayDeleteItem(g_sResourceList, sData[m_iResourceIndex])
	CheckNextResource()

	return PLUGIN_HANDLED
}

stock fm_ResourceLog(const sFormat[], any:...)
{
	static sMessage[512]; sMessage[0] = '\0'
	vformat(sMessage, charsmax(sMessage), sFormat, 2)

	new sLogFile[32]; get_time("resource_%Y%m.log", sLogFile, charsmax(sLogFile))
	log_to_file(sLogFile, "%s", sMessage)
	return 0
}
